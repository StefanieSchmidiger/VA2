% Conclusion
%
The aim of this project was to come up with a flexible application that routes data of connected devices to modems.\\
There was no need to start from scratch for this project as some ground work has been done by Andreas Albisser. He developed a hardware with four RS-232 interfaces to connect data generating and processing devices and four RS-232 interfaces to connect modems for data transmission. The base board has a header to plug in a Teensy 3.2. The Teensy is a small and powerful USB development board that works with Arduino libraries and acts a main micro controller for the base board.\\
The software Andreas Albisser developed for the Teensy 3.2 is complex and not well thought out. Because requirements were added during development, it is hard to maintain and expand.\\
The task description of this project features the use of a more powerful micro controller with Free RTOS as an operating system. Using a different micro controller requires hardware changes. There were two options on how to proceed: either redesign the base board for the new micro controller or design an adapter board that routes the used signals from the new micro controller down to the header of the Teensy 3.2. Because of time reasons, the second option was chosen and an adapter board was designed for the new micro controller used.\\
The Teensy 3.5 was chosen to replace the Teensy 3.2. The Teensy 3.5 features an SD card slot which is also part of the requirements, has more memory and is generally more powerful. Its identical pins are backwards compatible to the pinout of the Teensy 3.2, except for the extra pins because it is slightly longer and has more pins available to the user.\\
The Teensy 3.5 does have hardware debugging pins available on its backside but in order to use them, the on-board bootloader has to be removed as it is in control of the debug pins and cannot be silenced.\\
The hardware debugging pins are routed out on a SWD debug header but the footprint of the header was faulty in the first adapter board version ordered. This mistake was corrected and a second version ordered but the second version had poor inter layer connections. The faulty footprint was tested for correctness and seemed A third version was ordered which is probably better from what can be seen under the microscope. For time reasons, it could not be assembled and tested.\\
Software development was started after the first Teensy Adapter Board had been assembled and the hardware debugging pinout had been corrected manually. First, the software written by Andreas Albisser was analyzed. Because there was almost no documentation available about the software concept or test results, his software concept had to reverse engineered. Because it is complex and hard to expand, a new software concept was drawn up and implemented. The new software concept is according to the ISO/OSI layers and features three main tasks: one for the physical layer (ISO/OSI layer 1), one for the data link layer (ISO/OSI layer 2) and one for the network layer (ISO/OSI layer 3).\\
Layer 1 deals with bytes only and communicates with the hardware components directly. Layer 2 does the assembling of data packages and splits generated data packages into bytes. Layer 3 deals with packages only, their resending in case no acknowledge was received, generates acknowledges for received packages and extracts the payload to push out to the devices connected.\\
Inter task communication is realized with queues, where received data and data to transmit is passed up or down the ISO/OSI layers. All task take the state of all their queues into account during runtime so they will never generate data packages when the queue they should push it to is full. This way, data is never lost intentionally. Currently, each task may lose data unintentionally if a queue operation fails without it being full or empty but for apparently no reason. The only task that will drop data on purpose is the physical layer as it will flush a certain amount of bytes from its queue when full if new data is received and old data has not yet been processed.\\
Generally, the implementation provides about the same functionality as the software developed by Andreas Albisser. The only parameter missing that was part of Andreas' configuration is the limitation of throughput per wireless connection.\\
The base provided by this software is well documented and suitable for further expansion which was not the case with the previous software written for the Teensy 3.2.\\
The next step would be to implement package numbering instead of a system time stamp in the package header. Currently, the receiver does not know about missing packages when looking at the time stamp in the package header because the time stamp is not monotonically increasing. To ensure that packages are always received in the right order, either the sender waits for the acknowledge for a package before sending out the next one or the receiver implements a queue to reassemble packages in their right order before extracting the payload and sending it out to the correct device.\\
Aeroscout GmbH would also like to have data priority configurable. Currently, there is no configuration parameter that allows the user to prioritize one connected device over an other in case of unreliable wireless connection between on-board and off-board Serial Switch.\\
Also, logging has not been implemented yet because of time reasons. The Serial Switch currently prints out debug information on the shell but does not save it in a file.\\
Data encryption and interleaving were part of the task description but have not been implemented yet either.\\
Generally, the aim was of this project was to provide a software that works at least as good as the one provided by Andreas Albisser. Documentation any testing was done at the very end because development of a good and reliable product was prioritized.\\
When testing Andreas Albisser's application with an autopilot software as in a real use-case of Aeroscout GmbH, a connection could not be established successfully when acknowledges were configured for the application and on-board and off-board Serial Switches were communicating wirelessly.\\
When testing the new application with the same autopilot software, a connection was established successfully, even with acknowledges configured and wireless communication between the off-board and on-board devices.\\
Therefore, the goal of this project has been reached because the outcome seems to be of better quality than the state of the project upon start.\\
More time should have been invested into the testing phase to get more detailed results of the project outcome.
%
%
%
%
%
%
%
%
%
\section{Lessons Learned}
This project has been educational in many ways. It was my first time using the operating system Free RTOS and I was struggling during the starting phase because of too many new tools.\\
Also because the start of the project was rather slow and it felt like there was no real progress to show, I was neglecting the documentation up until the very end of the semester. This results in missing pictures in the documentation because they were not taken at that time and missing information because not all the configurations could be remembered when documenting a test case.\\
During the semester, I spent most time working on the project, implementing features and improving performance. This left me with little time for testing at the end where I should have stopped development earlier to invest more time in the testing phase so the person to follow up with this project would know exactly where he/she is at.\\
I do not have a lot of experience with schematics and layouts and did not know about the very high possibility of poor inter layer connections with internally ordered PCBs. Altium Designer together with finding the mistake in the poor inter layer connections cost me a lot of time during this project.\\
Also, I am a first time LaTex user and there were more than one occasion where I remembered Erich Styger's advice: "LaTex without version control is suicide". I can only agree with this statement and am forever glad he mentioned it so early.\\
Last but not least, it will be my goal to always keep the requirements in mind at all times during the next project. It is easy to get lost in coding and adding features. One should always take a step back, look at the requirements and the task description to make sure no element is forgotten. And maybe have a look at the grading paper to see where most time should be invested.