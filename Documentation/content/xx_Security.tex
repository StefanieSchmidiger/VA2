% 0_Security
%
The outcome of the software refactoring (see \autoref{sec:txtAddedFeatures}) and the system analysis (see \autoref{sec:SystemAnalysis}) was an application that runs stable and has enough CPU resources left for further features such as encryption and error correcting codes.\\
The main focus of this chapter is therefore the implementation of all features concerning the security of the data exchange. As mentioned in the \autoref{sec:txtAufgabenstellung}, Aeroscout GmbH would like the data exchange between the two Serial Switches to be encrypted and the exchanged data to be stored in a log file that cannot be modified without notice. Therefore, some means of information security has to be implemented.\\
According to \cite{Security_BuEdu}, information security is the practice of preventing unauthorized access, use or modification of information. Its key concepts are: \begin{itemize}
    \item \textbf{Availability:} All systems are functioning correctly and information is available when it is needed.
    \item \textbf{Integrity:} The same data is received as was transmitted, it cannot be modified without detection.
    \item \textbf{Confidentiality:} Data can only be read by the intended receiver. This can be ensured by encrypting the data exchanged so that it is unreadable by anyone who does not have the decryption key.
\end{itemize}
Each key concept and its implementation is elaborated in more detail in this chapter.
%
%
%
%
%
\section{Availability}
Availability of information refers to ensuring that authorized parties are able to access the information when needed.\\
Information only has value if the right people can access the data at the right times.\\
Ensuring availability is not part of the project requirements (see \autoref{sec:txtAufgabenstellung}), it is only listed here for completeness.
%
%
%
%
%
%
%
\section{Integrity}
Integrity of data can be assured with a hash function. A hash is a string or number generated from byte data. The resulting hash is of fixed length, and will vary widely with small variations in input.\\
The only way to recreate the input data from an ideal cryptographic hash function's output is to attempt a brute-force search of possible inputs to see if they produce a match, or use a rainbow table of matched hashes. Therefore, hashing is a one-way function that scrambles plain text to produce a unique message digest.\\
A CRC is an example of a simple hash function and is used to check if the message received matches the message transmitted.\\
Integrity only does not provide security against tempering with the message itself. If someone knows the hash algorithm used, a message can be modified and its hash value recalculated without the receiver knowing about it.
%
\subsection{Implementation of Integrity in Data Exchange}
Data integrity during communication is implemented with a CRC value in the package header and payload to detect bit errors (see \autoref{sec:txtSwOutcomeVa1}). The main microcontroller (K64F) on the Teensy 3.5 has a hardware CRC module that was used for faster CRC calculations. There is a Processor Expert component that uses the hardware CRC module and this component can be configured and used for easier CRC calculation. In the source code, it looks as follows:
\begin{lstlisting}
/* calculate CRC payload */
uint32_t crc16;
CRC1_ResetCRC(CRC1_DeviceData);
CRC1_SetCRCStandard(CRC1_DeviceData, LDD_CRC_MODBUS_16);
CRC1_GetBlockCRC(CRC1_DeviceData, pPackage->payload, pPackage->payloadSize, &crc16);
pPackage->crc16payload = (uint16_t) crc16;

/* calculate crc header */
CRC1_ResetCRC(CRC1_DeviceData);
CRC1_GetCRC8(CRC1_DeviceData, startChar);
CRC1_GetCRC8(CRC1_DeviceData, pPackage->packType);
CRC1_GetCRC8(CRC1_DeviceData, pPackage->devNum);
CRC1_GetCRC8(CRC1_DeviceData, pPackage->sessionNr);
CRC1_GetCRC8(CRC1_DeviceData, *((uint8_t*)(&pPackage->packNr) + 1));
CRC1_GetCRC8(CRC1_DeviceData, *((uint8_t*)(&pPackage->packNr) + 0));
CRC1_GetCRC8(CRC1_DeviceData, *((uint8_t*)(&pPackage->payloadNr) + 1));
CRC1_GetCRC8(CRC1_DeviceData, *((uint8_t*)(&pPackage->payloadNr) + 0));
CRC1_GetCRC8(CRC1_DeviceData, *((uint8_t*)(&pPackage->payloadSize) + 1));
pPackage->crc8Header = CRC1_GetCRC8(CRC1_DeviceData, *((uint8_t*)(&pPackage->payloadSize) + 0));
\end{lstlisting}
The CRC1 component uses the hardware CRC module for accelerated CRC computation.
%
\subsection{Implementation of Integrity for Log Data}
As seen in \autoref{sec:txtAufgabenstellung}, the application must also log the exchanged data and implement means to detect unauthorized modification of the log data. This can be achieved by implementing data integrity for the logged data.
The easiest way to implement integrity in the Logger task is by adding a hash log value for every package logged. The log file then looks similar to this:\\
\begin{lstlisting}
PackageType;DeviceNumber;SessionNumber;PackageNumber;PayloadNumber;PayloadSize;
CRC8_Header;Payload;CRC16_Payload;Hash

01;00;45;01;01;0011;88;FE092DFF0000000000000608C004039640;AD7C;154987
\end{lstlisting}
The Hash value was simply added after the CRC16\_Payload entry.\\
The problem is that, knowing the hash algorithm used, data can still be tempered with by adding or deleting log lines inside the log file. To detect this misusage, a hash value should not only be calculated for every package but also over the entire log file so that it becomes more difficult to modify log data undetected. But because it would again be easy for malusers to detect the hash algorithm applied, modify the log file and recalculate the hash not only over single log lines but also over the entire modified file, an additional item of security has to be added. Instead of only calculating the hash over the entire file (in addition to the hash calculation over single log lines), a secret random number is also put into the hash algorithm of the entire file before the final hash output is extracted and logged. It lies within the nature of a hash algorithm that the hash output changes drastically with just a small variation of the input value. It is therefore nearly impossible for unauthorized users to find the secret random number used by looking at other hash outputs that were calculated over the entire file. The same secret number could of course be added to the hash algorithm of each package as well.\\
Each K64F microcontroller has a 128-bit unique identification number per chip. This number can be used as the secret random number to be put into the hash algorithm.\\
There is a hardware encryption module on the K64F microcontroller that supports the following hash functions: \begin{itemize}
    \item \textbf{MD5:}\\
    According to \cite{MD5_Wikipedia}, the MD5 algorithm is a widely used hash function producing a 128-bit hash value. Although MD5 was initially designed to be used as a cryptographic hash function, it has been found to suffer from extensive vulnerabilities. It can still be used as a checksum to verify data integrity, but only against unintentional corruption. Like most hash functions, MD5 is neither encryption nor encoding. It can be cracked by a brute-force attack and suffers from extensive vulnerabilities.
    \item \textbf{SHA-1:}\\
    According to \cite{SHA1_Wikipedia}, the Secure Hash Algorithm 1 (SHA-1) is a cryptographic hash function which takes an input and produces a 160-bit (20-byte) hash value as an output. Since 2005 SHA-1 has not been considered secure anymore and it is recommended to use SHA-256 instead.
    \item \textbf{SHA-256:}\\
    The Secure Hash Algorithm 256 (SHA-256) is, just like the SHA-1, a cryptographic hash function. It generates a fixed size 256-bit (32-byte) hash output and is more secure than SHA-1.
\end{itemize}
%
Although there are no Processor Expert components for either of these hash functions, there is a Crypto Acceleraction Unit (CAU) provided by NXP which is a encryption software library especially designed for the ARM Coretex-M4. The CAU is used for ColdFire and ColdFire+ devices while the mmCAU is for Kinetis devices (ARM Coretex-M4). For more information, consult the user guide and software API in \cite{CAU_UserGuide}.\\
This library is currenty imported into the Kinetis Design Studio project and ready to be used inside the software. Logging integrity has not been implemented yet, only integrity in data exchange by using a CRC check with data packages. Either of the hashing algorithms can be used for logging integrity, the real security is provided by feeding the UID into the hash algorithm. The choice should therefore be made according to the computation speed of the used algorithm. The same value should be fed into each algorithm and the computation times compared.
%
%
%
%
%
%
%
%
%
\section{Confidentiality}
According to \cite{HashingVsEncrypting}, encryption ensures that only authorized individuals can decipher data. Encryption turns data into a series of unreadable characters, that are not of a fixed length.\\
There are two primary types of encryption: symmetric key encryption and public key encryption.\\
In \textbf{symmetric key encryption}, the key to both encrypt and decrypt is exactly the same. There are numerous standards for symmetric encryption, the popular being AES with a 256 bit key.\\
\textbf{Public key encryption} has two different keys, one used to encrypt data (the public key) and one used to decrypt it (the private key). The public key is made available for anyone to use to encrypt messages, however only the intended recipient has access to the private key, and therefore the ability to decrypt messages.\\
Symmetric encryption provides improved performance, and is simpler to use, however the key needs to be known by both the systems, the one encrypting and the one decrypting data.\\
According to \cite{InformationSecurity_Wikipedia}, information security uses cryptography to transform usable information into a form that renders it unusable by anyone other than an authorized user; this process is called encryption. Information that has been encrypted (rendered unusable) can be transformed back into its original usable form by an authorized user who possesses the cryptographic key, through the process of decryption. 
%
\subsection{Implementation of Encryption}%
The Teensy 3.5 uses the ARM Coretex-M4 microcontroller MK64FX512VMD12. In the MK64FX512xxD12 data sheet (see \cite{NXP_Datasheet}, p.1), it sais that this family supports the following hardware encryption algorithms:\begin{itemize}
    \item \textbf{DES:}\\
    According to \cite{DES_Wikipedia} and \cite{3DES_Wikipedia}, the Data Encryption Standard is a symmetric-key encryption algorithm developed in the early 1970s. It is now considered an insecure encryption standard and can be deciphered quickly, mostly due to its small key size (only 56 bit).  While the small key size was generally sufficient when the algorithm was designed, the increasing computational power made brute-force attacks feasible. 
    \item \textbf{3DES:}\\
    According to \cite{3DES_Wikipedia}, the Triple Data Encryption Standard is a symmetric-key encryption algorithm which applies the DES cipher algorithm three times to each data block. Thereby, all three encryption keys can be identical or independent Theoretically, the resulting key length can be up to 3 x 56 bits = 168 bits. No matter if the keys are independent or identical, the resulting key has a shorter length due to vulnerability to different attacks. 
    \item \textbf{AES:}\\
    According to \cite{AES_Wikipedia}, the Advanced Encryption Standard is, just like the DES, a symmetric-key algorithm and has been established in 2001. It superseded the DES and is now one of the most widely used encryption protocols. Its key sizes can either be 128 bits, 192 bits or 256 bits. 
\end{itemize}
There is a Crypto Acceleraction Unit (CAU) provided by NXP which is a encryption software library especially designed for the ARM Coretex-M4. The CAU is used for ColdFire and ColdFire+ devices while the mmCAU is for Kinetis devices (ARM Coretex-M4). For more information, consult the user guide and software API in \cite{CAU_UserGuide}. The mmCAU library has been added to the software Kinetis project already and tested, but encryption is still not supported in the current application.\\
Because the RF900x modem already supports encryption and uses the AES algorithm with a 128bit key, this algorithm should also be implemented in the application. The encryption key can be stored inside a header file so it is only visible to anyone who has access to the source code. Aeroscout claimed that it is not necessary for them to have a unique encryption key per Serial Switch and that they do not require the key to be changeable during runtime. If a change in encryption key is necessary, the header file would have to be changed and the application uploaded onto the two Serial Switches again.
%
%
\section{Conclusion}
Data integrity can be ensured by computing the hash value of the log file and adding a secret random number as the last input into the hash algorithm. The unique ID of the microcontroller could be used as this secret random number. Without adding a random number to the algorithm, the log file could easily be altered and the hash value recalculated simply by knowing the algorithm used.\\
Data confidentiality can be ensured by encrypting the communication with the AES (Advanced Encryption Standard) and storing the encryption key in a header file.\\
Both concepts have not been implemented yet in the current application but the required libraries have been added to the Kinetis Design Studio project and have successfully been tested.
%
%
%
%
%